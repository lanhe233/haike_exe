<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
	<style type="text/css">
		body>div{
			border: 1px solid #bbb;
			margin: 5px 0;
			padding: 5px;
		}
		[v-cloak]{
			display: none;
		}
		/*过渡效果1.0*/
		.fade-enter,.fade-leave-active{
			opacity: 0;
		}
		.fade-leave-active,.fade-enter-active{
			transition: opacity 2s;
		}
		/*过渡效果2.0*/
		.bounce-enter-active {
		  animation: bounce-in .5s;
		}
		.bounce-leave-active {
		  animation: bounce-out .5s;
		}
		@keyframes bounce-in {
		  0% {
		    transform: scale(0);
		  }
		  50% {
		    transform: scale(1.5);
		  }
		  100% {
		    transform: scale(1);
		  }
		}
		@keyframes bounce-out {
		  0% {
		    transform: scale(1);
		  }
		  50% {
		    transform: scale(1.5);
		  }
		  100% {
		    transform: scale(0);
		  }
		}
	</style>
</head>
<body>

	<!-- 过渡效果1.0 -->
	<div class="" id="box1">
		<button @click="show = !show">toggle</button>
		<transition name="fade">
			<p v-if="show">Hello</p>
		</transition>
	</div>
	<!-- 过渡效果2.0 -->
	<div id="example-2">
	  <button @click="show = !show">Toggle show</button>
	  <transition name="bounce">
	    <p v-if="show">Look at me!Look at me!Look at me!Look at me!</p>
	  </transition>
	</div>

	<!-- 给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else -->
	<div id="box3" v-cloak>
		<button :key="isEditing" @click="isEditing = !isEditing">
			{{isEditing?"save":"exit"}}
		</button>
	</div>

	<!-- 多个元素的过渡 -->
	<div id="box4" v-cloak>
		<table v-if="items.length>0">
			<tr v-for="item in items">
				<td>{{item.id}}</td>
				<td>{{item.name}}</td>
				<td>{{item.sex}}</td>
			</tr>
		</table>
		<p v-else>表格中没有内容</p>
		<p>可以这样使用，但是有一点需要注意：当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 <transition> 组件中的多个元素设置 key 是一个更好的实践。</p>
	</div>

	<!-- 使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡 -->
	<div id="box5">
		<button :key="docState">
			{{buttonMes}}
		</button>
	</div>

	<!-- Vue.set方法中，object参数不能是Vue实例或者Vue实例的根数据对象 -->
	<div id="box6">
		msg1: <input type="text" name="" v-model="msg.msg1">
		msg2: <input type="text" name="" v-model="msg.msg2">
	</div>

	<!-- Object.assign方法，新建一个对象，将data中已有的对象和需要添加的对象属性合并到空对象中，并把这个对象返回给data已有的对象，可以出发更新。直接把新属性加入到data中已有的对象中无法触发更新 -->
	<div id="box7">
		{{msg.a}}<input type="text" name="" v-model="msg.a">
		{{msg.b}}<input type="text" name="" v-model="msg.b">
		{{msg.c}}<input type="text" name="" v-model="msg.c">
	</div>

	<!-- set方法用在数组上，除了修改已有的，能否在数组现有长度之外添加新值 -->
	<div id="box8">
		{{arr[0]}},{{arr[1]}},{{arr[2]}}
	</div>

	<!-- 自定义指令v-focus -->
	<div id="box9">
		<!-- 全局指令 v-focus-global    局部指令 v-focus-part -->
		<input type="text" name="" placeholder="看，我已经获得焦点了" v-focus-part>
		全局定义的指令报错 不知道为啥？？？？？？？？？？？
	</div>

	<!-- 使用props传递数据 -->
	<div id="box10">
		父组件<input type="text" name="" v-model="message"><br>
			<!-- 如果是动态参数，要用绑定的方式！！固定参数才用message="" -->
		子组件<child :message="message"></child>	（又是全局的组件没注册没成功。。。。。。。。？？？？？？？）
	</div>

	<!-- axios&lodash&vue.watch选项 有跨域哦！ -->
	<div id="box11">
		Ask a yes/no question:<input type="text" name="" v-model="question">
		<p>{{answer}}</p>
	</div>

	<script src="https://unpkg.com/vue/dist/vue.js"></script>
	<script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
	<script type="text/javascript">

		// 过渡效果1.0
		new Vue({
			el:"#box1",
			data:{
				show:true
			}
		})
		// 过渡效果2.0
		new Vue({
		  el: '#example-2',
		  data: {
		    show: true
		  }
		})
		// 给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else
		new Vue({
		  el: '#box3',
		  data: {
		    isEditing: true
		  }
		})
		// 多个元素的过渡
		new Vue({
		  el: '#box4',
		  data: {
		    // items: []
		    items: [{id:1,name:"zhangsna",sex:"nan"},{id:1,name:"zhangsna",sex:"nan"},{id:1,name:"zhangsna",sex:"nan"},{id:1,name:"zhangsna",sex:"nan"}]
		  }
		})
		// 使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡
		new Vue({
		  el: '#box5',
		  data:{
		  	docState:"editing"
		  },
		  computed: {
		    buttonMes:function(){
		    	switch(this.docState){
		    		case "saved":return "edit";
		    		case "edited":return "save";
		    		case "editing":return "cancel";
		    	}
		    }
		  }
		})
		//Vue.set方法中，object参数不能是Vue实例或者Vue实例的根数据对象
		var vm = new Vue({
		  el: '#box6',
		  data:{
		  	msg:{
		  		msg1:"this is msg1"
		  	}
		  },
		  mounted:function(){
		  	this.$nextTick(function(){
		  		this.$set(this.msg,"msg2","this is msg2");
		  		//错误用法 this.$set(vm,"msg2","this is msg2");
		  	})
		  }
		})
		//Object.assign方法，新建一个对象，将data中已有的对象和需要添加的对象属性合并到空对象中，并把这个对象返回给data已有的对象，可以出发更新。直接把新属性加入到data中已有的对象中无法触发更新
		new Vue({
		  el: '#box7',
		  data:{
		  	msg:{
		  		a:"a"
		  	}
		  },
		  mounted:function(){
		  	this.$nextTick(function(){
		  		this.msg = Object.assign({},this.msg,{b:"b",c:"c"});
		  		// 错误用法 Object.assign(this.msg,{b:"b",c:"c"});
		  		// 不过其实用set方法就行了 不用这么折腾
		  	})
		  }
		})
		//set方法用在数组上，除了修改已有的，能否在数组现有长度之外添加新值
		new Vue({
		  el: '#box8',
		  data:{
		  	arr:[0,1]
		  },
		  mounted:function(){
		  	this.$nextTick(function(){
		  		this.$set(this.arr,1,"改");
		  		this.$set(this.arr,2,"增");
		  		//结论：set用在数组上，可以修改已有项，也可以新增项
		  	})
		  }
		})
		// 自定义指令v-focus
			// 局部定义
			new Vue({
			  el: '#box9',
			  directives:{
			  	//注意：！指令名不能用驼峰命名
			  	'focus-part':{
			  		//inserted是自定义指令的钩子函数，el为参数
			  		inserted:function(el){
			  			//dom元素.focus() 获取焦点
			  			//dom元素.blur() 失去焦点
			  			el.focus();
			  		}
			  	}
			  }
			})
			//全局定义  报错。。。。。。。。。。
			Vue.directive('focus-global',{
				inserted:function(el){
					el.focus();
				}
			})
		// 使用props传递数据
		var vm2 = new Vue({
		  el: '#box10',
		  data:{
		  	message:"hello"
		  },
		  components:{
		  	child:{
		  		props:['message'],
		  		template:'<span>{{ message }}</span>'
		  	}
		  }
		})
			// 全局又失败了。。。。。
			// Vue.component('child', {
			//   // 声明 props
			//   props: ['message'],
			//   // 就像 data 一样，prop 可以用在模板内
			//   // 同样也可以在 vm 实例中像 “this.message” 这样使用
			//   template: '<span>{{ message }}</span>'
			// })

		//computed属性的set和get
		var vm3 = new Vue({
			el:'',
			data:{
				a:1
			},
			computed:{
				plus:{
					get:function(){
						return this.a+8;
					},
					set:function(value){
						this.a = value;
					}
				}
			}
		})
			// 调用方法
			// vm3.plus  ->  9
			// vm3.plus = 55
			// vm3.a  ->  55

	</script>

	<!-- axios&lodash&vue.watch选项 有跨域哦！ -->
	<script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
	<script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
	<script>
	var watchExampleVM = new Vue({
	  el: '#box11',
	  data: {
	    question: '',
	    answer: 'I cannot give you an answer until you ask a question!'
	  },
	  watch: {
	    // 如果 question 发生改变，这个函数就会运行
	    question: function (newQuestion) {
	      this.answer = 'Waiting for you to stop typing...'
	      this.getAnswer()
	    }
	  },
	  methods: {
	    // _.debounce 是一个通过 lodash 限制操作频率的函数。
	    // 在这个例子中，我们希望限制访问yesno.wtf/api的频率
	    // ajax请求直到用户输入完毕才会发出
	    // 学习更多关于 _.debounce function (and its cousin
	    // _.throttle), 参考: https://lodash.com/docs#debounce
	    getAnswer: _.debounce(
	      function () {
	        var vm = this
	        if (this.question.indexOf('?') === -1) {
	          vm.answer = 'Questions usually contain a question mark. ;-)'
	          return
	        }
	        vm.answer = 'Thinking...'
	        axios.get('https://yesno.wtf/api')
	          .then(function (response) {
	            vm.answer = _.capitalize(response.data.answer)
	          })
	          .catch(function (error) {
	            vm.answer = 'Error! Could not reach the API. ' + error
	          })
	      },
	      // 这是我们为用户停止输入等待的毫秒数
	      500
	    )
	  }
	})
	</script>

	<!-- render函数实例 -->
	<div id="box12">
		<child :level="level">hello world</child>
	</div>
	<script>
		new Vue({
			el:'#box12',
			data:{
				level:3
			},
			components:{
				child:{
					props:['level'],
					render:function(createElement) {
						// 当你不使用 slot 属性向组件中传递内容时，比如 anchored-heading 中的 Hello world!, 这些子元素被存储在组件实例中的 $slots.default中
						return createElement('h'+this.level, this.$slots.default);
					}
				}
			}
		})
	</script>

	<!-- filter -->
	<div id="box13">
		<input type="text" name="" v-model.number='msg'>
		<p>金额：{{msg | fil}}</p>
	</div>
	<script>
		new Vue({
			el:'#box13',
			data:{
				msg:16.435126
			},
			filters:{
				// 注意fil有默认参数。不能直接去改this.msg
				fil:function(value) {
					// 必须先Number格式化，否则会报错，会认为是字符串，没有tofixed方法
					// return Number(value).toFixed(2);
					// 也可以用.number修饰符
					if (!isNaN(value)) {
						return value.toFixed(2);
					}
					return value;
				}
			}
		})
	</script>

	<!-- 路由 -->
	<div id="box14">
		<h1>Hello world!</h1>
		<!-- router-link 默认渲染成a标签 to属性指定链接 -->
		<router-link to="/foo">go to foo</router-link>
		<router-link to="/bar">go to bar</router-link>
		<!-- router-view 路由出口 路由匹配到的组件将渲染到这里 -->
		<router-view></router-view>
	</div> 
	<script>
		// 如果是模块化工程，需要Vue.use(VueRouter)才能使用 script直接引入不需要
		//以下代码为es2015写法

		// 1.定义路由要导入的组件  也可以从其他文件import进来
		const Foo = {template:'<div>this is foo</div>'}
		const Bar = {template:'<div>this is bar</div>'}

		// 2.定义路由
		// 每个路由应该定义一个组件component
		// component可以是通过Vue.entend()创建的组件构造器，或者只是一个组件配置对象
		// 一个路由为一个对象，同时定义多个用数组包起来
		const routes = [
			{path:'/foo',component:Foo},
			{path:'/bar',component:Bar}
		]

		// 3.创建router实例，然后传routes配置
		// 还有别的配置参数，以后介绍
		const router = new VueRouter({
			// routes = routes:routes 缩写
			routes
		})

		// 4.创建和挂载根实例
		new Vue({
			el:'#box14',
			// 这儿也是缩写
			router
		})

	</script>
	<style>
		/*router-link被渲染成a标签，在父中定义a的样式能起作用*/
		#box14 a{
			background-color: #f00;
		}
		#box14 div{
			color: green;
		}
	</style>

	<!-- 动态路由匹配 -->
	<div id="box15">
		<input type="text" name="" v-model="id">
		<router-link to="/user/60">go to user.id = {{id}}</router-link>
		<router-view></router-view>
	</div>
	<script>
		const router1 = new VueRouter({
			// 不好使 会报错
			// mode: 'history',
			routes:[
				// 动态路径参数id 以:开头 /user/?? 不管id是什么，都指向这一个路由
				// 参数值会被设置到 this.$route.params.id，可以在每个组件内使用。
				// 多段路径参数 如/user/:username/post/:post_id
				{path:'/user/:id',component:{template:'<div>user: {{$route.params.id}} '}}
			]
		})

		new Vue({
			el:'#box15',
			router:router1,
			data:{
				id:''
			}
		})

		// 注：当使用路由参数时，比如从user/11到user/18，原来的组件会复用，高效一些。但这也意味着原来的生命钩子不会再调用。如果想重新调用，可以简单地watch $route对象
		// 路由指定的组件中添加 watch:{ 
		// 						'$route' (to,from){
		// 							/*对路由变化作出相应*/
		// 						} 
		// 					}
		// 动态参数后面加？表示该参数可选  需要路径中部分非动态参数可选，括起来加？
		// 动态参数后面括号跟正则，表示只有参数符合正则才会匹配到这个路由
		// 动态参数:id换成* 表示任何都可以匹配
		// 有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。
	</script>

	<!-- vuex -->
	<script src="https://unpkg.com/vuex"></script>
	<div id="box16">
		<p>{{count}}</p>
		<p>
			<input @click="incre" type="button" name="" value="+">
			<input @click="decre" type="button" name="" value="-">
		</p>
	</div>
	<script>
		// 模块化中需要 Vue.use(Vuex)
		const store = new Vuex.Store({
			state:{
				count:0
			},
			mutations:{
				// mutations里面的函数需要传state参数 =-=
				incre:state => state.count++,
				decre:state => state.count--
			}
		})

		new Vue({
			el:'#box16',
			//获取store中的state，不能data直接返回，得用computed return
			// computed:{
			// 	//记住这个写法。。。。
			// 	count () {
			// 		return store.state.count
			// 	}
			// },
				// 一个一个写太麻烦了，可以用mapState函数辅助
				// computed:mapState(
				// 	// //如果和store.state一一对应，可写成数组
				// 	// [
				// 	// 	'count'
				// 	// ]
				// 		//如果和store.state不一一对应
				// 		{
				// 			//这种写法等同于 count: state => state.count
				// 			count:'count',
				// 			//但如果要使用this 需得写成常规函数
				// 			countPlusLocalState (state) {
				// 				return state.count+this.localState
				// 			}
				// 		}
				// ),
					// mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符（现处于 ECMASCript 提案 stage-3 阶段），我们可以极大地简化写法：

					// computed: {
					//   localComputed () { /* ... */ },
					//   // 使用对象展开运算符将此对象混入到外部对象中
					//   ...mapState({
					//     // ...
					//   })
					// }
			methods:{
				// data、computed、methods等等中的函数不能用箭头函数，会绑定父作用域，忘记了？
				incre () { 
					store.commit('incre') 
				},
				decre () { 
					store.commit('decre') 
				}
			}
			// 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。
			// store
		})
	</script>

	<div id="counter-event-example">
	  <p>{{ ispop }}</p>
	  <button-counter @increment="incrementTotal"></button-counter>
	  <button-counter @increment="incrementTotal"></button-counter>
	</div>
	<script>
		// Vue.component('button-counter', {
		//   template: '<button @click="increment">{{ counter }}</button>',
		//   data: function () {
		//     return {
		//       counter: 0
		//     }
		//   },
		//   methods: {
		//     increment  () {
		//       this.counter += 1
		//       this.$emit('increment')
		//     }
		//   },
		// });
		new Vue({
		  el: '#counter-event-example',
		  data: {
		    ispop: false
		  },
		  methods: {
		    incrementTotal () {
		      this.ispop = !this.ispop
		    }
		  },
		  components:{
		  	'buttonCounter':{
		  		template:'<button @click="increment"></button>',
		  		// data: function () {
		  		//   return {
		  		//     counter: 0
		  		//   }
		  		// },
		  		methods: {
		  		  increment () {
		  		    // this.counter += 1
		  		    this.$emit('increment')
		  		  }
		  		}
		  	}
		  }
		})
	</script>

</body>
</html>

<!-- 
import Vuex from 'vuex'
Vue.use(Vuex)

const store = new Vuex.Store({
	//options

	state:{
		//vuex store 实例的根state对象
		//每个应用仅仅包含一个store实例
		//将store选项注入到根vue实例
		data:1
	},
	mutations:{
		//更改vuex的store中的状态的唯一方法是提交mutations
		//回调函数接收state为第一个参数，payload为第二个参数
		setData (state,n) {
			state.data += n;
		}
		//不能直接调用，需 store.commit('increment',10)
		//在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：
		//提交 mutation 的另一种方式是直接使用包含 type 属性的对象：
		store.commit({
		  type: 'setData',
		  amount: 10
		})
		//Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：
		//最好提前在你的 store中初始化好所有所需属性。
		//当需要在对象上添加新属性时，你应该使用 Vue.set(obj, 'newProp', 123)

		//你可以在组件中使用 this.$store.commit('xxx') 提交 mutation，
		//或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。

		import { mapMutations } from 'vuex'

		export default {
		  // ...
		  methods: {
		    ...mapMutations([
		      'increment' // 映射this.increment() 为 this.$store.commit('increment')
		    ]),
		    ...mapMutations({
		      add: 'increment' // 映射 this.add() 为 this.$store.commit('increment')
		    })
		  }
		}
	},
	actions:{
		//在 store 上注册 action。处理函数接受一个 context 对象，包含以下属性：

		context = {
		  state,     // 等同于 store.state, 若在模块中则为局部状态
		  rootState, // 等同于 store.state, 只存在于模块中
		  commit,    // 等同于 store.commit
		  dispatch,  // 等同于 store.dispatch
		  getters    // 等同于 store.getters
		}

		//Action 提交的是 mutation，而不是直接变更状态。
		//Action 可以包含任意异步操作。
		increment (context) {
		    context.commit('increment')
		}

		//实践中，我们会经常会用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）：
		actions: {
		  increment ({ commit }) {
		    commit('increment')
		  }
		}

		//Action 通过 store.dispatch 方法触发：
		store.dispatch('increment')
	},
	getters:{
		//在 store 上注册 getter，getter 方法接受以下参数：
		  state,     // 如果在模块中定义则为模块的局部状态
		  getters,   // 等同于 store.getters
		  rootState  // 等同于 store.state
		
		//有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数
		//如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它 —— 无论哪种方式都不是很理想。

		//Vuex 允许我们在 store 中定义『getters』（可以认为是 store 的计算属性）。Getters 接受 state 作为其第一个参数

		doneTodos: state => {
		      return state.todos.filter(todo => todo.done)
		    }

		//Getters 会暴露为 store.getters 对象：
		store.getters.doneTodos

		//Getters 也可以接受其他 getters 作为第二个参数：
		getters: {
		  // ...
		  doneTodosCount: (state, getters) => {
		    return getters.doneTodos.length
		  }
		}

		//mapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性：
		import { mapGetters } from 'vuex'
		export default {
		  // ...
		  computed: {
		  // 使用对象展开运算符将 getters 混入 computed 对象中
		    ...mapGetters([
		      'doneTodosCount',
		      'anotherGetter',
		      // ...
		    ])
		  }
		}
		//如果你想将一个 getter 属性另取一个名字，使用对象形式：
		mapGetters({
		  // 映射 this.doneCount 为 store.getters.doneTodosCount
		  doneCount: 'doneTodosCount'
		})
	}
})

 -->